# Introduction

## Presence $\neq$ detection

::: {.column .center width="100%"}
{{< video https://www.youtube.com/watch?v=rexnDhbtq7E height="500px" width="1200px" >}}
:::

## Present, but not detected 
![_Photo by Caroline Kirk ([source](https://www.independent.co.uk/news/uk/wildlife-photographer-owl-camera-image-b1818585.html))_](images/bird.png){width=90%}

## Introduction


:::: {.columns}

::: {.column .center width=50%}
![](images/occ.png){width=100%}
:::

::: {.column width=50%}
- First published by @mackenzie2002 in the context of species occurrence modelling
- Many extensions: dynamic occupancy [@mackenzie_estimating_2003], multiple species [@rota_multispecies_2016], continuous detection process [@mackenzie_estimating_2003]...
- Here: original simple occupancy model
:::

::::

# Simple occupancy model

## Model

:::: {.columns}

::: {.column .center width=100%}
![](images/diagram.png){width=60%}
:::

::: {.column width=100%}
::: {.fragment}
For site $i$ and visit $j$:
$$
y_{ij} \sim Bern(z_i~p)
$$
$$
z_i \sim Bern(\psi)
$$
:::
:::

::::

# Occupancy models in R

## Simulate occupancy models in R

:::: {.columns}

::: {.column width=60%}
```{r}
#| code-line-numbers: "1-9|11-25"
set.seed(42)

M <- 100 # Number of sites
p <- 0.4 # Detection probability
psi <- 0.8 # Occupancy

# Simulate a number of visits for each site
nvisit <- rpois(n = M, lambda = 3)
nvisit[nvisit == 0] <- 1 # Don't allow zero visits

# Initialize vectors
z <- vector(mode = "numeric", length = M)
y <- vector(mode = "list", length = M)

for (i in 1:M) { # For each site
  # Simulate true presence/absence at site i
  zi <- rbinom(n = 1, size = 1, prob = psi)
  
  # Simulate observed presence/absence at site i 
  # for all visits
  yij <- rbinom(n = nvisit[i], 
                size = 1, prob = p*zi)
  
  z[i] <- zi # True sites states
  y[[i]] <- yij # Detections
}
```
:::

::: {.column width=40%}
![](images/diagram.png){width=100%}
:::
::::

## Simulate occupancy models in R

:::: {.nonincremental}
- True proportion of occupied sites ($z_i = 1$)
```{r}
sum(z)/M
```
::: {.fragment}
- Proportion of sites with at least one detection (naive occupancy)
```{r}
sum(sapply(y, function(yi) any(yi != 0)))/M
```
:::
::::

## Inference hypotheses


1.   Repeated visits (parameter identifiability)
2.   Site remains in the same state during the entire study period (closure assumption)
3.   No false detections

## Inference with `unmarked`

[`unmarked`](https://rbchan.github.io/unmarked/): R package for occupancy inference (maximum likelihood estimation = frequentist statistics).

## Format data {auto-animate=true}

```{r}
library(unmarked)

# Format the list of observed detections y
max_visit <- max(sapply(y, length)) # Get maximum number of detections

# Transform y to matrix
y_matrix <- matrix(data = NA,
                   nrow = M,
                   ncol = max_visit)
for (i in 1:M) { # For each site
  nvisit_i <- length(y[[i]]) # Get number of visits
  y_matrix[i, 1:nvisit_i] <- y[[i]] # Fill n-th first rows with detection history
}

# Cast y_matrix to unmarkedFrameOccu
y_occu <- unmarked::unmarkedFrameOccu(y_matrix)
```

## Format data {auto-animate=true}

```{r}
library(unmarked)

# Format the list of observed detections y
max_visit <- max(sapply(y, length)) # Get maximum number of detections

# Transform y to matrix
y_matrix <- matrix(data = NA,
                   nrow = M,
                   ncol = max_visit)
for (i in 1:M) { # For each site
  nvisit_i <- length(y[[i]]) # Get number of visits
  y_matrix[i, 1:nvisit_i] <- y[[i]] # Fill n-th first rows with detection history
}

# Each row contains the detections at a site, filled with NAs for 
# sites that have less visits than the most visited one
head(y_matrix, 3)

# Cast y_matrix to unmarkedFrameOccu
y_occu <- unmarked::unmarkedFrameOccu(y_matrix)
```

## Format data {auto-animate=true}

```{r}
library(unmarked)

# Format the list of observed detections y
max_visit <- max(sapply(y, length)) # Get maximum number of detections

# Transform y to matrix
y_matrix <- matrix(data = NA,
                   nrow = M,
                   ncol = max_visit)
for (i in 1:M) { # For each site
  nvisit_i <- length(y[[i]]) # Get number of visits
  y_matrix[i, 1:nvisit_i] <- y[[i]] # Fill n-th first rows with detection history
}

# Each row contains the detections at a site, filled with NAs for 
# sites that have less visits than the most visited one
# head(y_matrix, 3)

# Cast y_matrix to unmarkedFrameOccu
y_occu <- unmarked::unmarkedFrameOccu(y_matrix)
head(y_occu, 3)
```

## Inference with `unmarked::occu`

```{r}
# Infer occupancy
occ <- unmarked::occu(formula = ~1 ~1, 
                      data = y_occu)
```
::: {.nonincremental}
- `formula`: gives the formulas for the logit of $p$ and $\psi$.
- `data`: observed detections
:::

::: {.fragment}
```{r}
summary(occ)
```
:::

## Get estimates

Get estimates on the natural scale:

::::: {.columns}

:::: {.column width=50%}
```{r}
#| results: hold
# Get detection (p)
unmarked::backTransform(occ, type = "det")

# Get occupancy (state parameter, psi)
unmarked::backTransform(occ, type = "state")
```
::::

:::: {.column width=50%}
::: {.fragment}
```{r}
#| echo: false
#| fig-width: 7
#| fig-height: 6

library(ggplot2)

p_inf <- unmarked::predict(occ, 
                           type = "det",
                           backTransform = TRUE,
                           newdata = data.frame(1))
psi_inf <- unmarked::predict(occ, 
                             type = "state",
                             backTransform = TRUE,
                             newdata = data.frame(1))

umk_param_df <- data.frame(param = c("p", "p", "psi", "psi"),
                           type = c("inferred", "true", "inferred", "true"),
                           estimate = c(p_inf$Predicted, p,
                                        psi_inf$Predicted, psi),
                           min = c(p_inf$lower, NA,
                                   psi_inf$lower, NA),
                           max = c(p_inf$upper, NA,
                                   psi_inf$upper, NA))

ggplot(umk_param_df) +
  geom_errorbar(data = subset(umk_param_df, type == "inferred"),
                aes(xmin = min, xmax = max, y = param,
                    color = type)) +
  geom_point(aes(x = estimate, y = param,
                 color = type)) +
  theme_bw(base_size = 15) +
  xlim(0, 1) +
  theme(axis.title = element_blank(),
        legend.position = "bottom") +
  ggtitle("True and inferred occupancy parameters with unmarked")
```
:::
:::: 

:::::

## Inference with `cmdstanr`

- [Stan](https://mc-stan.org/): Bayesian software (optimized algorithms for the MCMC samplers)
- [`cmdstanr`](https://mc-stan.org/cmdstanr/) R package
- Binomial model specification (more efficient):
$$n_i \sim Binom({n_{\text{visit}}}_i, z_i~p) \quad \text{and} \quad z_i \sim Bern(\psi)$$

## Format data
```{r}
n <- sapply(y, sum) # number of detections
nvisit <- sapply(y, length) # number of visits

# List of parameters for Stan
dat <- list(M = M,
            n = n,
            nvisit = nvisit)
```

## Stan code blocks

```stan
data {
  // Code block to define data variables
}

parameters {
  // Code block to define parameters
}

model {
  // Code block to infer parameters
}
```

## Data block

Defining variables (typed)

```stan
data {
  int<lower=1> M; // Number of sites
  array[M] int nvisit; // Number of visits per sites-years
  array[M] int<lower=0> n; // Observations vector
}
```
## Parameters block

For parameters we want to infer (logit scale, more efficient in Stan)

```stan
parameters {
  real psi_logit; // value of psi on the logit scale
  real p_logit; // value of p on the logit scale
}

```
## Model block

::: {.nonincremental}
1. Priors: flat normal priors centered on zero = initializing the log-posterior with a log-transformed normal density
:::
```{.stan code-line-numbers="2-4"}
model {
  // 1. Priors
  target += normal_lpdf(psi_logit | 0, 3);
  target += normal_lpdf(p_logit | 0, 3);

  // 2. Variables
  int nvi;

  // 3. Model specification
  for (i in 1:M) { // iterate over sites
    nvi = nvisit[i]; // number of visits
    if (n[i] > 0) { // the species was seen
      // Update log-likelihood: species was detected | present
      target += log_inv_logit(psi_logit) + 
        binomial_logit_lpmf(n[i] | nvi, p_logit);
    } else {
      // Update log-likelihood: species was non-detected | present
      // or non-detected | absent
      target += log_sum_exp(log_inv_logit(psi_logit) + binomial_logit_lpmf(0 | nvi, p_logit), 
        log1m_inv_logit(psi_logit));
    }
  }
}
```

## Model block

::: {.nonincremental}
1. Priors: flat normal priors centered on zero = initializing the log-posterior with a log-transformed normal density
2. (Optional) Intermediate variables: `nvi` (number of visits for site $i$)
:::
```{.stan code-line-numbers="6-7"}
model {
  // 1. Priors
  target += normal_lpdf(psi_logit | 0, 3);
  target += normal_lpdf(p_logit | 0, 3);

  // 2. Variables
  int nvi;

  // 3. Model specification
  for (i in 1:M) { // iterate over sites
    nvi = nvisit[i]; // number of visits
    if (n[i] > 0) { // the species was seen
      // Update log-likelihood: species was detected | present
      target += log_inv_logit(psi_logit) + 
        binomial_logit_lpmf(n[i] | nvi, p_logit);
    } else {
      // Update log-likelihood: species was non-detected | present
      // or non-detected | absent
      target += log_sum_exp(log_inv_logit(psi_logit) + binomial_logit_lpmf(0 | nvi, p_logit), 
        log1m_inv_logit(psi_logit));
    }
  }
}
```

## Model block

::: {.nonincremental}
1. Priors: flat normal priors centered on zero = initializing the log-posterior with a log-transformed normal density
2. (Optional) Intermediate variables: `nvi` (number of visits for site $i$)
3. Model: Stan cannot model discrete variables, so we have to update the posterior probability density manually
:::
```{.stan code-line-numbers="9-23|"}
model {
  // 1. Priors
  target += normal_lpdf(psi_logit | 0, 3);
  target += normal_lpdf(p_logit | 0, 3);

  // 2. Variables
  int nvi;

  // 3. Model specification
  for (i in 1:M) { // iterate over sites
    nvi = nvisit[i]; // number of visits
    if (n[i] > 0) { // the species was seen
      // Update log-likelihood: species was detected | present
      target += log_inv_logit(psi_logit) + 
        binomial_logit_lpmf(n[i] | nvi, p_logit);
    } else {
      // Update log-likelihood: species was non-detected | present
      // or non-detected | absent
      target += log_sum_exp(log_inv_logit(psi_logit) + binomial_logit_lpmf(0 | nvi, p_logit), 
        log1m_inv_logit(psi_logit));
    }
  }
}
```

## Inference with `$sample`

```{r path}
#| echo: false
#| output: false
#| message: false

library(here)

post_folder <- here("data")
# dir.create(post_folder)
stan_file <- file.path(post_folder, "model.stan")
```

:::: {.nonincremental}
- compile the Stan model (Stan code is written in a file)

```{r compile}
#| message: false
library(cmdstanr)

model <- cmdstanr::cmdstan_model(stan_file = stan_file)
```
::: {.fragment}
- infer the `model` object
```{r infer}
#| output: false
stanfit <- model$sample(data = dat, # Data list
                        iter_warmup = 200, # Number of burn-in iterations
                        iter_sampling = 500, # Number of post-burn-in iterations
                        chains = 4, # Number of chains
                        parallel_chains = 4 # Number of parallel cores
                        )
```
:::

::::

## Get estimates

Get parameter estimates:

::::: {.columns}

:::: {.column width="50%"}
```{r}
(stan_inf <- stanfit$summary())
```
::::

:::: {.column width="50%"}
::: {.fragment}
```{r}
#| echo: false
#| fig-width: 7
#| fig-height: 6
stan_param_df <- data.frame(param = c("p", "p", "psi", "psi"),
                            type = c("inferred", "true", "inferred", "true"),
                            estimate = c(stan_inf$mean[stan_inf$variable == "p"], p,
                                         stan_inf$mean[stan_inf$variable == "psi"], psi),
                            min = c(stan_inf$q5[stan_inf$variable == "p"], NA,
                                    stan_inf$q5[stan_inf$variable == "psi"], NA),
                            max = c(stan_inf$q95[stan_inf$variable == "p"], NA,
                                    stan_inf$q95[stan_inf$variable == "psi"], NA))

ggplot(stan_param_df) +
  geom_errorbar(data = subset(stan_param_df, type == "inferred"),
                aes(xmin = min, xmax = max, y = param,
                    color = type)) +
  geom_point(aes(x = estimate, y = param,
                 color = type)) +
  theme_bw(base_size = 15) +
  xlim(0, 1) +
  theme(axis.title = element_blank(),
        legend.position = "bottom") +
  ggtitle("True and inferred occupancy parameters with Stan")
```
:::
::::
:::::

# Conclusion {auto-animate=true}

## Conclusion {auto-animate=true}

- simple occupancy model equations
- infer with `unmarked` and `cmdstanr`
- $p$ and $\psi$ often not constant: can be modeled as $\text{logit}(\psi_i) = \beta_0 + \beta_1 x_i$ or $\text{logit}(p_{ij}) = \beta_0 + \beta_1 x_{ij}$
- soon a blog post on the [tips and tricks blog](https://frbcesab.github.io/tips-and-tricks/)!

:::: {.column .center width="100%"}
::: {.fragment .fade-in}
::: {.fragment .grow}
::: {.fragment .shrink}
<br><br><br>
<p style="font-size:3em">Thank you!</p>
:::
:::
:::
::::

# References

## References

::: {#refs}
:::
<br>

### Other resources
::: {.nonincremental}
- Richard A. Erickson's [GitHub repository](https://github.com/bbennie/StanOccupancyModelTutorials) with Stan occupancy models tutorials
- Olivier Gimenez's [workshop](https://oliviergimenez.github.io/occupancy-workshop/) with resources on occupancy modelling with `unmarked`
:::
<br>
